C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ws2812
OBJECT MODULE PLACED IN .\ws2812.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\src\ws2812.c XSMALL INTR2 BROWSE INCDIR(..\inc) DEBUG PRINT(.\ws2812.l
                    -st) TABS(2) OBJECT(.\ws2812.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include <stdlib.h>
    3          #include "math.h"
    4          
    5          #define SEND_BIT0 {P51 = 1; NOP8(); P51 = 0; NOP16();}
    6          #define SEND_BIT1 {P51 = 1; NOP19(); P51 = 0; NOP3();}
    7          
    8          unsigned char bdata green_dat , red_dat , blue_dat;
    9          
   10          sbit green_dat_bit0 = green_dat^0;
   11          sbit green_dat_bit1 = green_dat^1;
   12          sbit green_dat_bit2 = green_dat^2;
   13          sbit green_dat_bit3 = green_dat^3;
   14          sbit green_dat_bit4 = green_dat^4;
   15          sbit green_dat_bit5 = green_dat^5;
   16          sbit green_dat_bit6 = green_dat^6;
   17          sbit green_dat_bit7 = green_dat^7;
   18          
   19          sbit red_dat_bit0 = red_dat^0;
   20          sbit red_dat_bit1 = red_dat^1;
   21          sbit red_dat_bit2 = red_dat^2;
   22          sbit red_dat_bit3 = red_dat^3;
   23          sbit red_dat_bit4 = red_dat^4;
   24          sbit red_dat_bit5 = red_dat^5;
   25          sbit red_dat_bit6 = red_dat^6;
   26          sbit red_dat_bit7 = red_dat^7;
   27          
   28          sbit blue_dat_bit0 = blue_dat^0;
   29          sbit blue_dat_bit1 = blue_dat^1;
   30          sbit blue_dat_bit2 = blue_dat^2;
   31          sbit blue_dat_bit3 = blue_dat^3;
   32          sbit blue_dat_bit4 = blue_dat^4;
   33          sbit blue_dat_bit5 = blue_dat^5;
   34          sbit blue_dat_bit6 = blue_dat^6;
   35          sbit blue_dat_bit7 = blue_dat^7;
   36          
   37          
   38          void WS2812_WriteColor(unsigned char green , unsigned char red , unsigned char blue)
   39          {
   40   1          green_dat = green;
   41   1          red_dat = red;
   42   1          blue_dat = blue;
   43   1          //发送绿色
   44   1          if(green_dat_bit7){SEND_BIT1}else{SEND_BIT0};
   45   1          if(green_dat_bit6){SEND_BIT1}else{SEND_BIT0};
   46   1          if(green_dat_bit5){SEND_BIT1}else{SEND_BIT0};
   47   1          if(green_dat_bit4){SEND_BIT1}else{SEND_BIT0};
   48   1          if(green_dat_bit3){SEND_BIT1}else{SEND_BIT0};
   49   1          if(green_dat_bit2){SEND_BIT1}else{SEND_BIT0};
   50   1          if(green_dat_bit1){SEND_BIT1}else{SEND_BIT0};
   51   1        if(green_dat_bit0){SEND_BIT1}else{SEND_BIT0};
   52   1          //发送红色
   53   1          if(red_dat_bit7){SEND_BIT1}else{SEND_BIT0};
   54   1          if(red_dat_bit6){SEND_BIT1}else{SEND_BIT0};
   55   1          if(red_dat_bit5){SEND_BIT1}else{SEND_BIT0};
   56   1          if(red_dat_bit4){SEND_BIT1}else{SEND_BIT0};
   57   1          if(red_dat_bit3){SEND_BIT1}else{SEND_BIT0};
   58   1          if(red_dat_bit2){SEND_BIT1}else{SEND_BIT0};
C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 2   

   59   1          if(red_dat_bit1){SEND_BIT1}else{SEND_BIT0};
   60   1        if(red_dat_bit0){SEND_BIT1}else{SEND_BIT0};
   61   1          //发送蓝色
   62   1          if(blue_dat_bit7){SEND_BIT1}else{SEND_BIT0};
   63   1          if(blue_dat_bit6){SEND_BIT1}else{SEND_BIT0};
   64   1          if(blue_dat_bit5){SEND_BIT1}else{SEND_BIT0};
   65   1          if(blue_dat_bit4){SEND_BIT1}else{SEND_BIT0};
   66   1          if(blue_dat_bit3){SEND_BIT1}else{SEND_BIT0};
   67   1          if(blue_dat_bit2){SEND_BIT1}else{SEND_BIT0};
   68   1          if(blue_dat_bit1){SEND_BIT1}else{SEND_BIT0};
   69   1        if(blue_dat_bit0){SEND_BIT1}else{SEND_BIT0};
   70   1      
   71   1      }
   72          
   73          #define WS2812_NUM 30//灯珠数量
   74          
   75          enum WS2812_RunMode mode = close_mode;
   76          unsigned char voiceGrade = 0;//音量等级
   77          unsigned char brightness = 50;//亮度
   78          unsigned char color_G[WS2812_NUM];
   79          unsigned char color_R[WS2812_NUM];
   80          unsigned char color_B[WS2812_NUM];
   81          unsigned char i;
   82          unsigned char randNum_G,randNum_R,randNum_B;
   83          
   84          bit firework_busy = 0;
   85          unsigned char firework_index = 0;
   86          
   87          unsigned char warterfull_index = 1;
   88          
   89          unsigned int gradient_index = 0;
   90          unsigned char gradientPhase_G = 0;
   91          unsigned char gradientPhase_R = 0;
   92          unsigned char gradientPhase_B = 0;
   93          unsigned char gradientColor_G = 0;
   94          unsigned char gradientColor_R = 0;
   95          unsigned char gradientColor_B = 0;
   96          
   97          unsigned char srand_seed = 0;
   98          
   99          unsigned char rainbowRoll_index = 0;
  100          unsigned char temp_R ,temp_G,temp_B;
  101          
  102          //显示
  103          void WS2812_Show()
  104          {
  105   1          unsigned char i;
  106   1          for ( i = 0; i < WS2812_NUM; i++)
  107   1          {
  108   2              WS2812_WriteColor(color_G[i],color_R[i],color_B[i]);
  109   2          }
  110   1          Delay300us();
  111   1      }
  112          
  113          void WS2812_RunTask()
  114          {
  115   1          while(1)
  116   1          {
  117   2              //随机颜色
  118   2              srand(Get_ADC12bitResult(0) + firework_index + warterfull_index + gradient_index + srand_seed);
  119   2              randNum_G = ((rand()*rand())%256) * brightness / 100;
  120   2      
  121   2              srand(100*sin(Get_ADC12bitResult(0) + firework_index + warterfull_index + gradient_index + srand_
             -seed)+100);
  122   2              randNum_R = ((rand()*rand())%256) * brightness / 100;
  123   2      
C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 3   

  124   2              srand(100*cos(Get_ADC12bitResult(0) + firework_index + warterfull_index + gradient_index + srand_
             -seed)+100);
  125   2              randNum_B = ((rand()*rand())%256) * brightness / 100;
  126   2      
  127   2              //选择模式 ，然后给三个颜色赋值
  128   2              switch (mode)
  129   2              {
  130   3      
  131   3                  //关闭模式
  132   3              case close_mode:
  133   3                  for(i = 0 ; i<WS2812_NUM ; i++)
  134   3                  {
  135   4                      color_G[i] = 0;
  136   4                      color_R[i] = 0;
  137   4                      color_B[i] = 0;
  138   4                  }
  139   3                  break;
  140   3      
  141   3                  //声控模式
  142   3              case voiceCtrl_mode:
  143   3                  voiceGrade = Get_ADC12bitResult(0)/(2300/WS2812_NUM);
  144   3                  if(voiceGrade > WS2812_NUM) voiceGrade = WS2812_NUM;
  145   3      
  146   3      
  147   3                  for ( i = 0; i < WS2812_NUM; i++)
  148   3                  {
  149   4                      if(i<voiceGrade) 
  150   4                      {
  151   5                          color_G[i] = randNum_G;
  152   5                          color_R[i] = randNum_R;
  153   5                          color_B[i] = randNum_B;
  154   5                      }   
  155   4                      else 
  156   4                      {
  157   5                          color_G[i] = 0;
  158   5                          color_R[i] = 0;
  159   5                          color_B[i] = 0;
  160   5                      }
  161   4                  }
  162   3                  //printf("G:%d R:%d B:%d\r\n",randNum_G,randNum_R,randNum_B);
  163   3            //printf("grade:%d  adc:%d\r\n",voiceGrade,Get_ADC12bitResult(0));  
  164   3                  break;
  165   3              
  166   3              //烟花模式
  167   3              case firework_mode:
  168   3                  if(firework_busy)
  169   3                  {
  170   4                      if(firework_index <= WS2812_NUM+(WS2812_NUM/3))
  171   4                      {
  172   5                          for ( i = 0; i < WS2812_NUM; i++)
  173   5                          {
  174   6                              if(i>=firework_index && i<(firework_index+(WS2812_NUM/3)) )
  175   6                              {
  176   7                                  color_G[i] = randNum_G;
  177   7                                  color_R[i] = randNum_R;
  178   7                                  color_B[i] = randNum_B;
  179   7                              }   
  180   6                              else 
  181   6                              {
  182   7                                  color_G[i] = 0;
  183   7                                  color_R[i] = 0;
  184   7                                  color_B[i] = 0;
  185   7                              }
  186   6                          }
  187   5                          firework_index++;
  188   5                          Delay_ms(50);
C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 4   

  189   5                      }
  190   4                      else 
  191   4                      {
  192   5                          firework_busy = 0;
  193   5                      }
  194   4                  }
  195   3                  else 
  196   3                  {
  197   4                      voiceGrade = Get_ADC12bitResult(0)/(2300/WS2812_NUM);
  198   4                      if(voiceGrade >= WS2812_NUM - (WS2812_NUM/3))
  199   4                      {
  200   5                          firework_busy = 1;
  201   5                          firework_index = 0;
  202   5                          if(randNum_G == randNum_R == randNum_B == 0)    randNum_R = 255 * brightness / 100;
  203   5                      }
  204   4                  }
  205   3                  break;
  206   3      
  207   3              case warterfull_mode1:   
  208   3                  for(i = 0; i<WS2812_NUM ;i++)
  209   3                  {
  210   4                      if(i<warterfull_index)
  211   4                      {
  212   5                          color_G[i] = randNum_G;
  213   5                          color_R[i] = randNum_R;
  214   5                          color_B[i] = randNum_B;
  215   5                      }
  216   4                      else
  217   4                      {
  218   5                          color_G[i] = 0;
  219   5                          color_R[i] = 0;
  220   5                          color_B[i] = 0;
  221   5                      }
  222   4                  }
  223   3                  warterfull_index++;
  224   3                  if(warterfull_index > WS2812_NUM) warterfull_index = 1;
  225   3                  Delay_ms(100);
  226   3      
  227   3                  break;
  228   3      
  229   3              case warterfull_mode2:   
  230   3                  for(i = 0; i<WS2812_NUM ;i++)
  231   3                  {
  232   4                      if(i<warterfull_index)
  233   4                      {
  234   5                          color_G[i] = randNum_G;
  235   5                          color_R[i] = randNum_R;
  236   5                          color_B[i] = randNum_B;
  237   5                      }
  238   4                  }
  239   3                  warterfull_index++;
  240   3                  if(warterfull_index > WS2812_NUM) warterfull_index = 1;
  241   3                  Delay_ms(100);
  242   3      
  243   3                  break;
  244   3      
  245   3              case warterfull_mode3: 
  246   3                  if(gradient_index == 0)//获取随机相位
  247   3                  {
  248   4                      gradientPhase_G = randNum_G;
  249   4                      gradientPhase_R = randNum_R;
  250   4                      gradientPhase_B = randNum_B;
  251   4                  }
  252   3                  gradientColor_G = (128*sin(0.0125*(gradient_index+gradientPhase_G))+128) * brightness/100;
  253   3                  gradientColor_R = (128*sin(0.0125*(gradient_index+gradientPhase_R))+128) * brightness/100;
  254   3                  gradientColor_B = (128*sin(0.0125*(gradient_index+gradientPhase_B))+128) * brightness/100;
C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 5   

  255   3                  for(i = 0; i<WS2812_NUM ;i++)
  256   3                  {
  257   4                      if(i<warterfull_index)
  258   4                      {
  259   5                          color_G[i] = gradientColor_G;
  260   5                          color_R[i] = gradientColor_R;
  261   5                          color_B[i] = gradientColor_B;
  262   5                      }
  263   4                      else
  264   4                      {
  265   5                          color_G[i] = 0;
  266   5                          color_R[i] = 0;
  267   5                          color_B[i] = 0;
  268   5                      }
  269   4                  }
  270   3                  gradient_index++;
  271   3                  if(gradient_index == 500)
  272   3                  {
  273   4                      gradient_index = 1;
  274   4                      warterfull_index++;
  275   4                      if(warterfull_index > WS2812_NUM) 
  276   4                      {
  277   5                          warterfull_index = 1;
  278   5                          gradient_index = 0;
  279   5                      }
  280   4                      
  281   4                  }
  282   3                  Delay_ms(1);
  283   3                  break;
  284   3      
  285   3              case gradient_mode:
  286   3                  if(gradient_index == 0)//获取随机相位
  287   3                  {
  288   4                      gradientPhase_G = randNum_G;
  289   4                      gradientPhase_R = randNum_R;
  290   4                      gradientPhase_B = randNum_B;
  291   4                  }
  292   3                  gradientColor_G = (128*sin(0.0125*(gradient_index+gradientPhase_G))+128) * brightness/100;
  293   3                  gradientColor_R = (128*sin(0.0125*(gradient_index+gradientPhase_R))+128) * brightness/100;
  294   3                  gradientColor_B = (128*sin(0.0125*(gradient_index+gradientPhase_B))+128) * brightness/100;
  295   3                  for(i = 0; i<WS2812_NUM ;i++)
  296   3                  {
  297   4                      color_G[i] = gradientColor_G;
  298   4                      color_R[i] = gradientColor_R;
  299   4                      color_B[i] = gradientColor_B;
  300   4                  }
  301   3                  gradient_index++;
  302   3                  if(gradient_index == 500)   gradient_index = 0;
  303   3                  Delay_ms(1);
  304   3      
  305   3                  
  306   3                  break;
  307   3      
  308   3              case rainbow_mode:
  309   3                  for(i = 0; i<WS2812_NUM ;i++)
  310   3                  {
  311   4                      if(i<(int)(WS2812_NUM/7))
  312   4                      {
  313   5                          color_R[i] = 255 * brightness/100;
  314   5                          color_G[i] = (165 / (int)(WS2812_NUM / 7)) * i* brightness/100;
  315   5                          color_B[i] = 0;
  316   5                      }
  317   4                      else if (i<2*(int)(WS2812_NUM/7))
  318   4                      {
  319   5                          color_R[i] = 255 * brightness/100;
  320   5                          color_G[i] = (165 + (((255-165) / (int)(WS2812_NUM / 7)) * (i - (WS2812_NUM/7))))* br
C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 6   

             -ightness/100;
  321   5                          color_B[i] = 0;
  322   5                      }
  323   4                      else if (i<3*(int)(WS2812_NUM/7))
  324   4                      {
  325   5                          color_R[i] = (255 - ((255/(int)(WS2812_NUM / 7)) * (i - 2*(WS2812_NUM/7)))) * brightn
             -ess/100;
  326   5                          color_G[i] = 255 * brightness/100;
  327   5                          color_B[i] = 0;
  328   5                      }
  329   4                      else if (i<4*(int)(WS2812_NUM/7))
  330   4                      {
  331   5                          color_R[i] = 0;
  332   5                          color_G[i] = 255 * brightness/100;
  333   5                          color_B[i] = ( 255 / (int)(WS2812_NUM / 7) * (i - 3*(WS2812_NUM/7))) * brightness/100
             -;
  334   5                      }
  335   4                      else if (i<5*(int)(WS2812_NUM/7))
  336   4                      {
  337   5                          color_R[i] = 0;
  338   5                          color_G[i] = (255 - ((255/(int)(WS2812_NUM / 7)) * (i - 4*(WS2812_NUM/7)))) * brightn
             -ess/100;
  339   5                          color_B[i] = 255 * brightness/100;
  340   5                      } 
  341   4                      else if (i<6*(int)(WS2812_NUM/7))
  342   4                      {
  343   5                          color_R[i] = ( 139 / (int)(WS2812_NUM / 7) * (i - 5*(WS2812_NUM/7))) * brightness/100
             -;
  344   5                          color_G[i] = 0;
  345   5                          color_B[i] = 255 * brightness/100;
  346   5                      } 
  347   4                      else if (i<WS2812_NUM)
  348   4                      {
  349   5                          color_R[i] = (139 + (((255-139) / (WS2812_NUM - 6*(int)(WS2812_NUM / 7))) * (1+i - 6*
             -(WS2812_NUM/7))))* brightness/100;
  350   5                          color_G[i] = 0;
  351   5                          color_B[i] = (255 - ((255/(WS2812_NUM - 6*(int)(WS2812_NUM / 7))) * (1+i - 6*(WS2812_
             -NUM/7)))) * brightness/100;
  352   5                      } 
  353   4                      else
  354   4                      {
  355   5                          color_R[i] = 0;
  356   5                          color_G[i] = 0;
  357   5                          color_B[i] = 0;
  358   5                      }
  359   4                  }
  360   3                  break;
  361   3              case rainbowRoll_mode:
  362   3                  if(rainbowRoll_index == 0)
  363   3                  {
  364   4                      for(i = 0; i<WS2812_NUM ;i++)
  365   4                      {
  366   5                          if(i<(int)(WS2812_NUM/7))
  367   5                          {
  368   6                              color_R[i] = 255 * brightness/100;
  369   6                              color_G[i] = (165 / (int)(WS2812_NUM / 7)) * i* brightness/100;
  370   6                              color_B[i] = 0;
  371   6                          }
  372   5                          else if (i<2*(int)(WS2812_NUM/7))
  373   5                          {
  374   6                              color_R[i] = 255 * brightness/100;
  375   6                              color_G[i] = (165 + (((255-165) / (int)(WS2812_NUM / 7)) * (i - (WS2812_NUM/7))))
             -* brightness/100;
  376   6                              color_B[i] = 0;
  377   6                          }
  378   5                          else if (i<3*(int)(WS2812_NUM/7))
C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 7   

  379   5                          {
  380   6                              color_R[i] = (255 - ((255/(int)(WS2812_NUM / 7)) * (i - 2*(WS2812_NUM/7)))) * bri
             -ghtness/100;
  381   6                              color_G[i] = 255 * brightness/100;
  382   6                              color_B[i] = 0;
  383   6                          }
  384   5                          else if (i<4*(int)(WS2812_NUM/7))
  385   5                          {
  386   6                              color_R[i] = 0;
  387   6                              color_G[i] = 255 * brightness/100;
  388   6                              color_B[i] = ( 255 / (int)(WS2812_NUM / 7) * (i - 3*(WS2812_NUM/7))) * brightness
             -/100;
  389   6                          }
  390   5                          else if (i<5*(int)(WS2812_NUM/7))
  391   5                          {
  392   6                              color_R[i] = 0;
  393   6                              color_G[i] = (255 - ((255/(int)(WS2812_NUM / 7)) * (i - 4*(WS2812_NUM/7)))) * bri
             -ghtness/100;
  394   6                              color_B[i] = 255 * brightness/100;
  395   6                          } 
  396   5                          else if (i<6*(int)(WS2812_NUM/7))
  397   5                          {
  398   6                              color_R[i] = ( 139 / (int)(WS2812_NUM / 7) * (i - 5*(WS2812_NUM/7))) * brightness
             -/100;
  399   6                              color_G[i] = 0;
  400   6                              color_B[i] = 255 * brightness/100;
  401   6                          } 
  402   5                          else if (i<WS2812_NUM)
  403   5                          {
  404   6                              color_R[i] = (139 + (((255-139) / (WS2812_NUM - 6*(int)(WS2812_NUM / 7))) * (1+i 
             -- 6*(WS2812_NUM/7))))* brightness/100;
  405   6                              color_G[i] = 0;
  406   6                              color_B[i] = (255 - ((255/(WS2812_NUM - 6*(int)(WS2812_NUM / 7))) * (1+i - 6*(WS2
             -812_NUM/7)))) * brightness/100;
  407   6                          } 
  408   5                          else
  409   5                          {
  410   6                              color_R[i] = 0;
  411   6                              color_G[i] = 0;
  412   6                              color_B[i] = 0;
  413   6                          }
  414   5                      }
  415   4                      rainbowRoll_index++;
  416   4                  }
  417   3                  else 
  418   3                  {
  419   4                      temp_R = color_R[0];
  420   4                      temp_G = color_G[0];
  421   4                      temp_B = color_B[0];
  422   4                      for(i = 1; i<WS2812_NUM ; i++)
  423   4                      {
  424   5                          color_R[i-1] = color_R[i];
  425   5                          color_G[i-1] = color_G[i];
  426   5                          color_B[i-1] = color_B[i];
  427   5                      }
  428   4                      color_R[WS2812_NUM - 1] = temp_R;
  429   4                      color_G[WS2812_NUM - 1] = temp_G;
  430   4                      color_B[WS2812_NUM - 1] = temp_B;
  431   4                  }
  432   3                  Delay_ms(50);
  433   3                  break;
  434   3      
  435   3              case test_mode:
  436   3      
  437   3                  break;
  438   3              default:
C251 COMPILER V5.60.0,  ws2812                                                             31/07/23  12:09:18  PAGE 8   

  439   3                  break;
  440   3              }
  441   2      
  442   2              if(mode != rainbowRoll_mode) rainbowRoll_index = 0;
  443   2      
  444   2              //显示
  445   2              WS2812_Show();
  446   2              srand_seed++;
  447   2          }
  448   1      }
  449          
  450          
  451          
  452          void WS2812_setMode(enum WS2812_RunMode modeToSet)
  453          {
  454   1          mode = modeToSet;
  455   1      }
  456          
  457          void WS2812_setBrighness(unsigned char brightnessToSet)
  458          {
  459   1          if(brightnessToSet<=100)
  460   1              brightness = brightnessToSet;
  461   1          else    brightness = 100;
  462   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      4261     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       113     ------
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =         3     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        72     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
