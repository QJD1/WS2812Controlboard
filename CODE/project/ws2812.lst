C251 COMPILER V5.60.0,  ws2812                                                             27/07/23  11:42:22  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE ws2812
OBJECT MODULE PLACED IN .\ws2812.obj
COMPILER INVOKED BY: D:\keil\C251\BIN\C251.EXE ..\src\ws2812.c XSMALL INTR2 BROWSE INCDIR(..\inc) DEBUG PRINT(.\ws2812.l
                    -st) TABS(2) OBJECT(.\ws2812.obj) 

stmt  level    source

    1          #include "main.h"
    2          #include <stdlib.h>
    3          #include "math.h"
    4          
    5          #define SEND_BIT0 {P51 = 1; NOP8(); P51 = 0; NOP16();}
    6          #define SEND_BIT1 {P51 = 1; NOP19(); P51 = 0; NOP3();}
    7          
    8          unsigned char bdata green_dat , red_dat , blue_dat;
    9          
   10          sbit green_dat_bit0 = green_dat^0;
   11          sbit green_dat_bit1 = green_dat^1;
   12          sbit green_dat_bit2 = green_dat^2;
   13          sbit green_dat_bit3 = green_dat^3;
   14          sbit green_dat_bit4 = green_dat^4;
   15          sbit green_dat_bit5 = green_dat^5;
   16          sbit green_dat_bit6 = green_dat^6;
   17          sbit green_dat_bit7 = green_dat^7;
   18          
   19          sbit red_dat_bit0 = red_dat^0;
   20          sbit red_dat_bit1 = red_dat^1;
   21          sbit red_dat_bit2 = red_dat^2;
   22          sbit red_dat_bit3 = red_dat^3;
   23          sbit red_dat_bit4 = red_dat^4;
   24          sbit red_dat_bit5 = red_dat^5;
   25          sbit red_dat_bit6 = red_dat^6;
   26          sbit red_dat_bit7 = red_dat^7;
   27          
   28          sbit blue_dat_bit0 = blue_dat^0;
   29          sbit blue_dat_bit1 = blue_dat^1;
   30          sbit blue_dat_bit2 = blue_dat^2;
   31          sbit blue_dat_bit3 = blue_dat^3;
   32          sbit blue_dat_bit4 = blue_dat^4;
   33          sbit blue_dat_bit5 = blue_dat^5;
   34          sbit blue_dat_bit6 = blue_dat^6;
   35          sbit blue_dat_bit7 = blue_dat^7;
   36          
   37          
   38          void WS2812_WriteColor(unsigned char green , unsigned char red , unsigned char blue)
   39          {
   40   1          green_dat = green;
   41   1          red_dat = red;
   42   1          blue_dat = blue;
   43   1          //发送绿色
   44   1          if(green_dat_bit7){SEND_BIT1}else{SEND_BIT0};
   45   1          if(green_dat_bit6){SEND_BIT1}else{SEND_BIT0};
   46   1          if(green_dat_bit5){SEND_BIT1}else{SEND_BIT0};
   47   1          if(green_dat_bit4){SEND_BIT1}else{SEND_BIT0};
   48   1          if(green_dat_bit3){SEND_BIT1}else{SEND_BIT0};
   49   1          if(green_dat_bit2){SEND_BIT1}else{SEND_BIT0};
   50   1          if(green_dat_bit1){SEND_BIT1}else{SEND_BIT0};
   51   1        if(green_dat_bit0){SEND_BIT1}else{SEND_BIT0};
   52   1          //发送红色
   53   1          if(red_dat_bit7){SEND_BIT1}else{SEND_BIT0};
   54   1          if(red_dat_bit6){SEND_BIT1}else{SEND_BIT0};
   55   1          if(red_dat_bit5){SEND_BIT1}else{SEND_BIT0};
   56   1          if(red_dat_bit4){SEND_BIT1}else{SEND_BIT0};
   57   1          if(red_dat_bit3){SEND_BIT1}else{SEND_BIT0};
   58   1          if(red_dat_bit2){SEND_BIT1}else{SEND_BIT0};
C251 COMPILER V5.60.0,  ws2812                                                             27/07/23  11:42:22  PAGE 2   

   59   1          if(red_dat_bit1){SEND_BIT1}else{SEND_BIT0};
   60   1        if(red_dat_bit0){SEND_BIT1}else{SEND_BIT0};
   61   1          //发送蓝色
   62   1          if(blue_dat_bit7){SEND_BIT1}else{SEND_BIT0};
   63   1          if(blue_dat_bit6){SEND_BIT1}else{SEND_BIT0};
   64   1          if(blue_dat_bit5){SEND_BIT1}else{SEND_BIT0};
   65   1          if(blue_dat_bit4){SEND_BIT1}else{SEND_BIT0};
   66   1          if(blue_dat_bit3){SEND_BIT1}else{SEND_BIT0};
   67   1          if(blue_dat_bit2){SEND_BIT1}else{SEND_BIT0};
   68   1          if(blue_dat_bit1){SEND_BIT1}else{SEND_BIT0};
   69   1        if(blue_dat_bit0){SEND_BIT1}else{SEND_BIT0};
   70   1      
   71   1      }
   72          
   73          #define WS2812_NUM 30//灯珠数量
   74          
   75          enum WS2812_RunMode mode = close_mode;
   76          unsigned char voiceGrade = 0;//音量等级
   77          unsigned char brightness = 50;//亮度
   78          unsigned char color_G[WS2812_NUM];
   79          unsigned char color_R[WS2812_NUM];
   80          unsigned char color_B[WS2812_NUM];
   81          unsigned char i;
   82          unsigned char randNum_G,randNum_R,randNum_B;
   83          
   84          bit firework_busy = 0;
   85          unsigned char firework_index = 0;
   86          
   87          unsigned char warterfull_index = 1;
   88          
   89          unsigned int gradient_index = 0;
   90          unsigned char gradientPhase_G = 0;
   91          unsigned char gradientPhase_R = 0;
   92          unsigned char gradientPhase_B = 0;
   93          unsigned char gradientColor_G = 0;
   94          unsigned char gradientColor_R = 0;
   95          unsigned char gradientColor_B = 0;
   96          
   97          unsigned char srand_seed = 0;
   98          
   99          //显示
  100          void WS2812_Show()
  101          {
  102   1          unsigned char i;
  103   1          for ( i = 0; i < WS2812_NUM; i++)
  104   1          {
  105   2              WS2812_WriteColor(color_G[i],color_R[i],color_B[i]);
  106   2          }
  107   1          Delay300us();
  108   1      }
  109          
  110          void WS2812_RunTask()
  111          {
  112   1          while(1)
  113   1          {
  114   2              //随机颜色
  115   2              srand(Get_ADC12bitResult(0) + firework_index + warterfull_index + gradient_index + srand_seed);
  116   2              randNum_G = ((rand()*rand())%256) * brightness / 100;
  117   2      
  118   2              srand(100*sin(Get_ADC12bitResult(0) + firework_index + warterfull_index + gradient_index + srand_
             -seed)+100);
  119   2              randNum_R = ((rand()*rand())%256) * brightness / 100;
  120   2      
  121   2              srand(100*cos(Get_ADC12bitResult(0) + firework_index + warterfull_index + gradient_index + srand_
             -seed)+100);
  122   2              randNum_B = ((rand()*rand())%256) * brightness / 100;
C251 COMPILER V5.60.0,  ws2812                                                             27/07/23  11:42:22  PAGE 3   

  123   2      
  124   2              //选择模式 ，然后给三个颜色赋值
  125   2              switch (mode)
  126   2              {
  127   3      
  128   3                  //关闭模式
  129   3              case close_mode:
  130   3                  for(i = 0 ; i<WS2812_NUM ; i++)
  131   3                  {
  132   4                      color_G[i] = 0;
  133   4                      color_R[i] = 0;
  134   4                      color_B[i] = 0;
  135   4                  }
  136   3                  break;
  137   3      
  138   3                  //声控模式
  139   3              case voiceCtrl_mode:
  140   3                  voiceGrade = Get_ADC12bitResult(0)/(2300/WS2812_NUM);
  141   3                  if(voiceGrade > WS2812_NUM) voiceGrade = WS2812_NUM;
  142   3      
  143   3      
  144   3                  for ( i = 0; i < WS2812_NUM; i++)
  145   3                  {
  146   4                      if(i<voiceGrade) 
  147   4                      {
  148   5                          color_G[i] = randNum_G;
  149   5                          color_R[i] = randNum_R;
  150   5                          color_B[i] = randNum_B;
  151   5                      }   
  152   4                      else 
  153   4                      {
  154   5                          color_G[i] = 0;
  155   5                          color_R[i] = 0;
  156   5                          color_B[i] = 0;
  157   5                      }
  158   4                  }
  159   3                  //printf("G:%d R:%d B:%d\r\n",randNum_G,randNum_R,randNum_B);
  160   3            //printf("grade:%d  adc:%d\r\n",voiceGrade,Get_ADC12bitResult(0));  
  161   3                  break;
  162   3              
  163   3              //烟花模式
  164   3              case firework_mode:
  165   3                  if(firework_busy)
  166   3                  {
  167   4                      if(firework_index <= WS2812_NUM+(WS2812_NUM/3))
  168   4                      {
  169   5                          for ( i = 0; i < WS2812_NUM; i++)
  170   5                          {
  171   6                              if(i>=firework_index && i<(firework_index+(WS2812_NUM/3)) )
  172   6                              {
  173   7                                  color_G[i] = randNum_G;
  174   7                                  color_R[i] = randNum_R;
  175   7                                  color_B[i] = randNum_B;
  176   7                              }   
  177   6                              else 
  178   6                              {
  179   7                                  color_G[i] = 0;
  180   7                                  color_R[i] = 0;
  181   7                                  color_B[i] = 0;
  182   7                              }
  183   6                          }
  184   5                          firework_index++;
  185   5                          Delay_ms(50);
  186   5                      }
  187   4                      else 
  188   4                      {
C251 COMPILER V5.60.0,  ws2812                                                             27/07/23  11:42:22  PAGE 4   

  189   5                          firework_busy = 0;
  190   5                      }
  191   4                  }
  192   3                  else 
  193   3                  {
  194   4                      voiceGrade = Get_ADC12bitResult(0)/(2300/WS2812_NUM);
  195   4                      if(voiceGrade >= WS2812_NUM - (WS2812_NUM/3))
  196   4                      {
  197   5                          firework_busy = 1;
  198   5                          firework_index = 0;
  199   5                          if(randNum_G == randNum_R == randNum_B == 0)    randNum_R = 255 * brightness / 100;
  200   5                      }
  201   4                  }
  202   3                  break;
  203   3      
  204   3              case warterfull_mode1:   
  205   3                  for(i = 0; i<WS2812_NUM ;i++)
  206   3                  {
  207   4                      if(i<warterfull_index)
  208   4                      {
  209   5                          color_G[i] = randNum_G;
  210   5                          color_R[i] = randNum_R;
  211   5                          color_B[i] = randNum_B;
  212   5                      }
  213   4                      else
  214   4                      {
  215   5                          color_G[i] = 0;
  216   5                          color_R[i] = 0;
  217   5                          color_B[i] = 0;
  218   5                      }
  219   4                  }
  220   3                  warterfull_index++;
  221   3                  if(warterfull_index > WS2812_NUM) warterfull_index = 1;
  222   3                  Delay_ms(100);
  223   3      
  224   3                  break;
  225   3      
  226   3              case warterfull_mode2:   
  227   3                  for(i = 0; i<WS2812_NUM ;i++)
  228   3                  {
  229   4                      if(i<warterfull_index)
  230   4                      {
  231   5                          color_G[i] = randNum_G;
  232   5                          color_R[i] = randNum_R;
  233   5                          color_B[i] = randNum_B;
  234   5                      }
  235   4                  }
  236   3                  warterfull_index++;
  237   3                  if(warterfull_index > WS2812_NUM) warterfull_index = 1;
  238   3                  Delay_ms(100);
  239   3      
  240   3                  break;
  241   3      
  242   3              case warterfull_mode3: 
  243   3                  if(gradient_index == 0)//获取随机相位
  244   3                  {
  245   4                      gradientPhase_G = randNum_G;
  246   4                      gradientPhase_R = randNum_R;
  247   4                      gradientPhase_B = randNum_B;
  248   4                  }
  249   3                  gradientColor_G = (128*sin(0.0125*(gradient_index+gradientPhase_G))+128) * brightness/100;
  250   3                  gradientColor_R = (128*sin(0.0125*(gradient_index+gradientPhase_R))+128) * brightness/100;
  251   3                  gradientColor_B = (128*sin(0.0125*(gradient_index+gradientPhase_B))+128) * brightness/100;
  252   3                  for(i = 0; i<WS2812_NUM ;i++)
  253   3                  {
  254   4                      if(i<warterfull_index)
C251 COMPILER V5.60.0,  ws2812                                                             27/07/23  11:42:22  PAGE 5   

  255   4                      {
  256   5                          color_G[i] = gradientColor_G;
  257   5                          color_R[i] = gradientColor_R;
  258   5                          color_B[i] = gradientColor_B;
  259   5                      }
  260   4                      else
  261   4                      {
  262   5                          color_G[i] = 0;
  263   5                          color_R[i] = 0;
  264   5                          color_B[i] = 0;
  265   5                      }
  266   4                  }
  267   3                  gradient_index++;
  268   3                  if(gradient_index == 500)
  269   3                  {
  270   4                      gradient_index = 1;
  271   4                      warterfull_index++;
  272   4                      if(warterfull_index > WS2812_NUM) 
  273   4                      {
  274   5                          warterfull_index = 1;
  275   5                          gradient_index = 0;
  276   5                      }
  277   4                      
  278   4                  }
  279   3                  Delay_ms(1);
  280   3                  break;
  281   3      
  282   3              case gradient_mode:
  283   3                  if(gradient_index == 0)//获取随机相位
  284   3                  {
  285   4                      gradientPhase_G = randNum_G;
  286   4                      gradientPhase_R = randNum_R;
  287   4                      gradientPhase_B = randNum_B;
  288   4                  }
  289   3                  gradientColor_G = (128*sin(0.0125*(gradient_index+gradientPhase_G))+128) * brightness/100;
  290   3                  gradientColor_R = (128*sin(0.0125*(gradient_index+gradientPhase_R))+128) * brightness/100;
  291   3                  gradientColor_B = (128*sin(0.0125*(gradient_index+gradientPhase_B))+128) * brightness/100;
  292   3                  for(i = 0; i<WS2812_NUM ;i++)
  293   3                  {
  294   4                      color_G[i] = gradientColor_G;
  295   4                      color_R[i] = gradientColor_R;
  296   4                      color_B[i] = gradientColor_B;
  297   4                  }
  298   3                  gradient_index++;
  299   3                  if(gradient_index == 500)   gradient_index = 0;
  300   3                  Delay_ms(1);
  301   3      
  302   3                  
  303   3                  break;
  304   3      
  305   3              case test_mode:
  306   3      
  307   3                  break;
  308   3              default:
  309   3                  break;
  310   3              }
  311   2      
  312   2              //显示
  313   2              WS2812_Show();
  314   2              srand_seed++;
  315   2          }
  316   1      }
  317          
  318          
  319          
  320          void WS2812_setMode(enum WS2812_RunMode modeToSet)
C251 COMPILER V5.60.0,  ws2812                                                             27/07/23  11:42:22  PAGE 6   

  321          {
  322   1          mode = modeToSet;
  323   1      }
  324          
  325          void WS2812_setBrighness(unsigned char brightnessToSet)
  326          {
  327   1          if(brightnessToSet<=100)
  328   1              brightness = brightnessToSet;
  329   1          else    brightness = 100;
  330   1      }


Module Information          Static   Overlayable
------------------------------------------------
  code size            =      3035     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =       109     ------
  bit size             =         1     ------
  ebit size            =    ------     ------
  bitaddressable size  =         3     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =        67     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
